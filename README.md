ОПИСАНИЕ
ВАРИАНТ 1
Реализация жадного 2-аппроксимационного алгоритма для задачи о вершинном покрытии графа на Python.
Задача о вершинном покрытии-- найти минимальное подмножество вершин, такое что каждое ребро графа инцидентно хотя бы одной вершине из этого подмножества.
Алгоритм демонстрирует эффективный компромисс между точностью решения и вычислительной сложностью, что делает его практичным для решения NP-трудных задач оптимизации.

ОБЬЯСНЕНИЕ КОДА Python о вершинном покрытии
Инициализация структур данных:cover = set()
remaining_edges = set(edges)
· set() - создает пустое множество
· set(edges) - преобразует список ребер в множество (удаляет дубликаты)
· cover - будет хранить вершины покрытия
· remaining_edges - копия исходных ребер для обработки
Основной цикл:
while remaining_edges:
· while - цикл выполняется пока есть непокрытые ребра
· Условие: remaining_edges не пустое (автоматически преобразуется в False при пустоте)
Выбор и обработка ребра:u, v = remaining_edges.pop()
· .pop() - извлекает и удаляет произвольный элемент из множества
· u, v - распаковка кортежа (ребра) в две переменные
Добавление вершин в покрытие:
cover.add(u)
cover.add(v)
· .add() - добавляет элемент в множество
· Если вершина уже есть в множестве, она не добавляется повторно (свойство множества)
Фильтрация ребер:
remaining_edges = {(a, b) for a, b in remaining_edges
                  if a != u and a != v and b != u and b != v}
· Генератор множества - создает новое множество на основе старого
· (a, b) for a, b in remaining_edges - перебирает все оставшиеся ребра
· Условие фильтрации: a != u and a != v and b != u and b != v
  · Оставляет только те ребра, у которых ОБЕ вершины НЕ равны u И НЕ равны v
  · Удаляет все ребра, инцидентные вершинам u или v
  Запуск алгоритма:cover = greedy_vertex_cover(edges)
Вывод результатов:
print(f"Размер покрытия: {len(cover)}")
print(f"Покрытие: {cover}")
 f-строка - форматированный вывод с подстановкой переменных
· len(cover) - возвращает количество элементов в множестве
Проверка корректности:for u, v in edges:
    assert u in cover or v in cover, f"Ребро ({u}, {v}) не покрыто"
    for u, v in edges:
   {v}) не покрыто"
Входные данные и вызов:edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), 
(5, 6), (6, 7), (7, 8), (8, 9), (9, 0)]
cover = analyze_vertex_cover(edges)
edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), 
(5, 6), (6, 7), (7, 8), (8, 9), (9, 0)]

ВРЕМЕННАЯ СЛОЖНОСТЬ:· O(E²) где E - количество ребер
· На каждой итерации обрабатывается O(E) ребер

РЕЗУЛЬТАТЫ ВЫПОЛНЕНИЯ:Размер покрытия: 10
Покрытие: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
Все ребра покрыты 

КОЭФФИЦИЕНТ АППРОКСИМАЦИИ:
Теоретический: α = 2
Фактический: 10/5 = 2 (для цикла из 10 вершин)
Алгоритм гарантирует 2-аппроксимацию для любых графов

Ответ на КОНТРОЛЬНЫЙ ВОПРОС:Вопрос 4(Почему жадный алгоритм для задачи о вершинном покрытии дает 2-аппроксимацию?)
Ответ: Жадный алгоритм выбирает ребро и добавляет обе его вершины в покрытие. Каждое выбранное ребро требует как минимум одной вершины в оптимальном покрытии (иначе оно осталось бы непокрытым). Поскольку алгоритм добавляет две вершины на ребро, размер покрытия не более чем в 2 раза превышает оптимальный. Таким образом, алгоритм гарантирует 2-аппроксимацию.




    






